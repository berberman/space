<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Space - Setting up a Haskell development environment on Arch Linux</title>
        <link rel="stylesheet" href="./css/default.css" />
        <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="./">Space</a>
            </div>
            <nav>
                <a href="./">Home</a>
                <a href="./contact.html">Contact</a>
                <a href="./archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Setting up a Haskell development environment on Arch Linux</h1>
            <article>
    <section class="header">
        Posted on October 27, 2020
        
            by berberman
        
    </section>
    <section>
        <p><del>Once you accept the principles of Arch Linux – being simplicity and modernity – everything goes easier.</del> In this article, we will use up-to-date Haskell ecosystem by using system provided Haskell packages, getting rid of awkward stack which could eat huge amount of your disk space. We won’t going to <a href="https://github.com/Gabriel439/haskell-nix">nix</a> or <a href="https://gitlab.haskell.org/haskell/ghcup-hs">ghcup</a>, since they are both general Haskell toolchain solutions, not specific to Arch Linux.</p>
<h2 id="preface">Preface</h2>
<p>If you get pandoc, shellcheck, or other Haskell programs installed on your system, you will find that a bunch of packages with <code>haskell-</code> prefix emerge frequently when rolling the system, which is pretty verbose and noisy. Thus, many of general users, i.e. not Haskell developers, always complain that “why every time I tries to roll my system, there are so many Haskell packages to be updated, and wait… What Is Haskell?” Remember that Arch Linux official repositories are not built for Haskell developers, <code>haskell-</code> packages distributed there are only for programs written in Haskell. To save disk space, Haskell executables do not bundle their dependencies, so libraries are stripped into independent packages, consistent with Haskell package management. Other languages’ distributions follow the similar strategy, whereas a vexing problem arise particularly in Haskell packaging. Haskell packages are packaged and linked dynamically, but GHC does not provide a stable <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>, since its specific hash method acting on circular dependences, which lie ubiquitously involving tests, will cause the <a href="https://en.wikipedia.org/wiki/Soname">soname</a> of shared libraries interdependent. Consequently, you may notice that the entire Haskell packages in <a href="https://www.archlinux.org/packages/">[community]</a> are not <a href="https://reproducible.archlinux.org/">reproducible</a>. If a Haskell library changes, all dependent packages are required to be rebuilt. For us, it is inevitable to rebuild and reinstall all tools which depend on those shared libraries after updating <code>haskell-</code> packages. Some users choose to avoid getting involved this sort of cheating, using static version Haskell programs as alternative. However, as a Haskell developer, we can make full use of these shared libraries.</p>
<h2 id="configure-cabal">Configure Cabal</h2>
<p>We will use <a href="https://cabal.readthedocs.io/en/3.2/">Cabal</a> without sandboxes as our build tool, and system level GHC as our compiler. Let’s install them via system package management tool:</p>
<pre><code># pacman -S ghc cabal-install</code></pre>
<p>Generate the configuration and update hackage index as normal:</p>
<pre><code>$ cabal update</code></pre>
<p>Cabal are able to find system Haskell packages installed by pacman. If you try to use Cabal directly to compiling your project now, you will get:</p>
<blockquote>
<p>Could not find module ‘Prelude’…</p>
</blockquote>
<p>indicating that many packages which would come with GHC are missing. This is because currently system Haskell packages provide only dynamic linked shared libraries, which can be used only when GHC is running in dynamic. So we have to configure <code>~/.cabal/config</code> as following:</p>
<pre><code>library-vanilla: False
shared: True
executable-dynamic: True
program-default-options
  ghc-options: -dynamic</code></pre>
<p>And if we want to install a Haskell program from cabal, we have to run:</p>
<pre><code>cabal install --ghc-options=-dynamic [package to install]</code></pre>
<p>to let Cabal call GHC enabled dynamic linking.</p>
<h2 id="install-the-language-server">Install the language server</h2>
<p>Personally, I would recommend <a href="https://github.com/haskell/haskell-language-server">haskell-language-server</a>, which is active in developing and provide unprecedented coding experience. Because we choose using dynamic GHC, we have to compile HLS by ourselves with dynamic option. Clone the source code:</p>
<pre><code>$ git clone https://github.com/haskell/haskell-language-server --recurse-submodules
$ cd haskell-language-server</code></pre>
<p><strong>IMPORTANT:</strong> Configure the HLS project locally:</p>
<pre><code>$ cabal configure --disable-library-vanilla --enable-shared --enable-executable-dynamic --ghc-options=-dynamic</code></pre>
<p>Finally install it:</p>
<pre><code>$ ./cabal-hls-install latest</code></pre>
<p>Next step is choosing your favorite editor, and installing following the instruction in HLS. That’s it, happy coding!</p>
<h2 id="conclusion">Conclusion</h2>
<p>Indeed, we have encountered the first impediment in installing HLS. Using dynamic GHC with system Haskell packages is double-edged, suggesting that we have to face various lurking issues.</p>
<p>Pros:</p>
<ul>
<li>it’s impossible to get stuck into dependency hell (we always use the latest Haskell packages)</li>
<li>far less disk usage is required</li>
</ul>
<p>Cons:</p>
<ul>
<li>out-of-date packages are not available (so there will be slightly fewer libraries we can use)</li>
<li>programs involving GHC should be given special treatment (make sure GHC is called with dynamic flag)</li>
</ul>
<p>The last is kind of troublesome, because maintainers should patch the source of those programs to let them call GHC properly. Here are some examples:</p>
<ul>
<li><a href="https://github.com/archlinux/svntogit-community/blob/59c345b179aee0d71aca0df5974056bb0ac15ae2/trunk/PKGBUILD#L31">Agda</a></li>
<li><a href="https://github.com/archlinux/svntogit-community/blob/f06b6574b90addc54a67c664532b8175496e2495/trunk/dynamic-compilation.patch#L8">xmonad</a></li>
<li><a href="https://github.com/archlinux/svntogit-community/blob/833e37fbe6de1f07e106d81e9e0ef9e08f0513ad/trunk/PKGBUILD#L20">doctest</a></li>
<li>…</li>
</ul>
<p>Overall, it seems that we’d better don’t touch these dynamic things in Haskell developing… Anyway, I’m posting this to illustrate that working with <code>haskell-</code> packages is possible. It is worth mentioning that <strong>all Haskell packages</strong>, and even <strong>a half of entire Arch Linux packages</strong> are maintaining by <a href="https://github.com/felixonmars">felixonmars</a> individually, who is dedicated to these unpaid contributions. As an Arch Linux user, I would like to express my high respects to his greatest professionalism and responsibility. Next time, I will introduce my Haskell packaging tool <a href="https://github.com/berberman/arch-hs">arch-hs</a>, which can be used by both Arch Linux Haskell packagers and Haskell developers.</p>
    </section>
</article>

        </main>

        <footer>
            © 2020 ❤
            <a href="https://github.com/berberman">berberman</a>
            WTFPL
        </footer>
    </body>
</html>
