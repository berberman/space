#!/usr/bin/env python3
"""
THIS FILE IS GENERATED BY LLM.
"""

import sys
import subprocess
import tempfile
import argparse
from pathlib import Path
from html.parser import HTMLParser


class BodyExtractor(HTMLParser):
    
    def __init__(self, remove_p=True):
        super().__init__()
        self.remove_p = remove_p
        self.in_body = False
        self.in_p = False
        self.body_content = []
        self.depth = 0
        
    def handle_starttag(self, tag, attrs):
        if tag == 'body':
            self.in_body = True
        elif self.in_body and tag == 'p' and self.depth == 0:
            if self.remove_p:
                self.in_p = True
                self.depth += 1
            else:
                # Don't remove <p>, just track that we're in body content
                self.in_p = True
                self.depth += 1
                attrs_str = ' '.join(f'{k}="{v}"' for k, v in attrs)
                if attrs_str:
                    self.body_content.append(f'<{tag} {attrs_str}>')
                else:
                    self.body_content.append(f'<{tag}>')
        elif self.in_p or (self.in_body and not self.remove_p):
            self.depth += 1
            attrs_str = ' '.join(f'{k}="{v}"' for k, v in attrs)
            if attrs_str:
                self.body_content.append(f'<{tag} {attrs_str}>')
            else:
                self.body_content.append(f'<{tag}>')
    
    def handle_endtag(self, tag):
        if tag == 'body':
            self.in_body = False
        elif self.in_p and tag == 'p' and self.depth == 1:
            if not self.remove_p:
                self.body_content.append(f'</{tag}>')
            self.in_p = False
            self.depth -= 1
        elif self.in_p or (self.in_body and not self.remove_p):
            self.depth -= 1
            self.body_content.append(f'</{tag}>')
    
    def handle_data(self, data):
        if self.in_p or (self.in_body and not self.remove_p):
            self.body_content.append(data)
    
    def handle_startendtag(self, tag, attrs):
        if self.in_p or (self.in_body and not self.remove_p):
            attrs_str = ' '.join(f'{k}="{v}"' for k, v in attrs)
            if attrs_str:
                self.body_content.append(f'<{tag} {attrs_str}/>')
            else:
                self.body_content.append(f'<{tag}/>')
    
    def get_content(self):
        return ''.join(self.body_content)


def typst_math_to_mathml(math_formula: str, block_mode: bool = False) -> str:

    if block_mode:
        template = """
#import "mathyml/lib.typ": *
#import "mathyml/prelude.typ": *
#show math.equation: to-mathml

$
  {formula}
$
"""
    else:
        template = """
#import "mathyml/lib.typ": *
#import "mathyml/prelude.typ": *
#show math.equation: to-mathml

${formula}$
"""
    script_dir = Path(__file__).parent.resolve()
    with tempfile.NamedTemporaryFile(mode='w', suffix='.typ', dir=script_dir, delete=False) as f:
        typst_file = Path(f.name)
        f.write(template.replace('{formula}', math_formula))
    try:
        result = subprocess.run(
            ['typst', 'compile', str(typst_file), '--format', 'html', '--features', 'html', '-'],
            capture_output=True,
            text=True,
            cwd=str(script_dir),
            check=False
        )
        if result.returncode != 0:
            raise RuntimeError(f"Typst compilation failed (exit code {result.returncode}):\nstderr: {result.stderr}\nstdout: {result.stdout}")
        html_output = result.stdout
        if not html_output:
            raise RuntimeError(f"Typst produced no output\nstderr: {result.stderr}\nstdout: {result.stdout}")
        parser = BodyExtractor(remove_p=not block_mode)
        parser.feed(html_output)
        mathml = parser.get_content()
        return mathml.strip()
    except Exception as e:
        raise RuntimeError(f"Failed to convert Typst to MathML: {e}") from e
    finally:
        try:
            if typst_file.exists():
                typst_file.unlink()
        except Exception as e:
            print(f"Warning: Failed to delete temporary file {typst_file}: {e}", file=sys.stderr)

def main():
    parser = argparse.ArgumentParser(
        description='Convert Typst math formulas to MathML',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""Examples:
  Inline mode:  %(prog)s 'sum_1^2 x + 1'
  Block mode:   %(prog)s --block 'sum_1^2 x + 1'
""")
    parser.add_argument('formula', help='Typst math formula (without $ delimiters)')
    parser.add_argument('--block', action='store_true', help='Use block/display mode instead of inline mode')
    args = parser.parse_args()
    mathml = typst_math_to_mathml(args.formula, block_mode=args.block)
    print(mathml)

if __name__ == '__main__':
    main()
